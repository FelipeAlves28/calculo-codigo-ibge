"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ErrorTreatment_1 = require("./ErrorTreatment");
const chalk = require("chalk");
const error = chalk.red;
const warning = chalk.keyword('orange');
function ErrorHandle(target, methodName) {
    registerMetadata(target, methodName);
}
exports.ErrorHandle = ErrorHandle;
function ErrorHandleDafault(target, methodName) {
    registerMetadata(target, methodName, true);
}
exports.ErrorHandleDafault = ErrorHandleDafault;
function registerMetadata(target, methodName, defaultHandle = false) {
    let type = Reflect.getMetadata("design:paramtypes", target, methodName);
    if (!type) {
        logMissingConfiguration();
        return;
    }
    if (type.length == 0) {
        logMissingParams(methodName);
        return;
    }
    ErrorTreatment_1.ErrorTreatment.register(type[0].name, (err, req, res, next) => {
        return target[methodName](err, req, res, next, defaultHandle);
    });
}
function logMissingParams(methodName) {
    const signature = '     Method signature -> (err: any, req: Request, res: Response, next: NextFunction)\n';
    console.warn(warning(`[HandleWarning] Insufficient params in handle ${methodName}()\n${signature}`));
}
function logMissingConfiguration() {
    if (!ErrorTreatment_1.ErrorTreatment.getInstance().logMissingConfigurationError) {
        const config = "    {\n" +
            "       \"compilerOptions\": {\n" +
            "           [...]\n" +
            "           \"experimentalDecorators\": true,\n" +
            "           \"emitDecoratorMetadata\": true,\n" +
            "           [...]\n" +
            "      }";
        console.error(error(`[HandleError] MissingConfigurationError: configure in tsconfig.json file: \n ${config}`));
        ErrorTreatment_1.ErrorTreatment.getInstance().logMissingConfigurationError = true;
    }
}
//# sourceMappingURL=ErrorHandle.js.map